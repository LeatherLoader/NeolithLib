//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using NeolithLib.API.Events;


namespace NeolithLib.API
{
	public class LockableEvents : Facepunch.MonoBehaviour
	{
		private static LockableEvents mInstance = null;
		
		public LockableEvents() 
		{
			LockableEvents.mInstance = this;
		}
		
		public void Awake()
		{
			DontDestroyOnLoad (this.gameObject);
		}

		public static void RegisterDeployableHandler<T>() where T : UnityEngine.MonoBehaviour
		{
			LockableEvents.mInstance.gameObject.AddComponent<T> ();
		}

		public static bool InvokeSteamIdHasAccess(GameObject gameObject, ulong steamId) {
			PreSteamIdHasAccessEvent preEvent = new PreSteamIdHasAccessEvent (gameObject.GetComponent<LockableObject> (), steamId);
			gameObject.SendMessage ("PreSteamIdHasAccessCommand", preEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PreSteamIdHasAccessCommand", preEvent, SendMessageOptions.DontRequireReceiver);

			if (!preEvent.Cancelled) {
				preEvent.Result = preEvent.LockableObject.HasAccess(preEvent.SteamId);
			}

			PostSteamIdHasAccessEvent postEvent = new PostSteamIdHasAccessEvent (preEvent.LockableObject, preEvent.SteamId, preEvent.Result, preEvent.Handled, preEvent.Cancelled);
			gameObject.SendMessage ("PostSteamIdHasAccessCommand", postEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PostSteamIdHasAccessCommand", postEvent, SendMessageOptions.DontRequireReceiver);

			return postEvent.Result;
		}

		public static bool InvokeSteamIdHasAccess(GameObject gameObject, Controllable character) {
			PreControllableHasAccessEvent preEvent = new PreControllableHasAccessEvent (gameObject.GetComponent<LockableObject> (), character);
			gameObject.SendMessage ("PreControllableHasAccessCommand", preEvent, SendMessageOptions.DontRequireReceiver);
			character.SendMessage ("PreControllableHasAccessCommand", preEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PreControllableHasAccessCommand", preEvent, SendMessageOptions.DontRequireReceiver);

			if (!preEvent.Cancelled) {
				preEvent.Result = preEvent.LockableObject.HasAccess(preEvent.Controllable);
			}

			PostControllableHasAccessEvent postEvent = new PostControllableHasAccessEvent (preEvent.LockableObject, preEvent.Controllable, preEvent.Result, preEvent.Handled, preEvent.Cancelled);
			gameObject.SendMessage ("PostControllableHasAccessCommand", postEvent, SendMessageOptions.DontRequireReceiver);
			character.SendMessage ("PostControllableHasAccessCommand", postEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PostControllableHasAccessCommand", postEvent, SendMessageOptions.DontRequireReceiver);

			return postEvent.Result;
		}

		public static bool InvokeIsLockAccess(GameObject gameObject) {
			PreIsLockActiveEvent preEvent = new PreIsLockActiveEvent (gameObject.GetComponent<LockableObject> ());
			gameObject.SendMessage ("PreIsLockActiveCommand", preEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PreIsLockActiveCommand", preEvent, SendMessageOptions.DontRequireReceiver);

			if (!preEvent.Cancelled) {
				preEvent.Result = preEvent.LockableObject.IsLockActive();
			}

			PostIsLockActiveEvent postEvent = new PostIsLockActiveEvent (preEvent.LockableObject, preEvent.Result, preEvent.Handled, preEvent.Cancelled);
			gameObject.SendMessage ("PostIsLockActiveCommand", postEvent, SendMessageOptions.DontRequireReceiver);
			LockableEvents.mInstance.SendMessage ("PostIsLockActiveCommand", postEvent, SendMessageOptions.DontRequireReceiver);

			return postEvent.Result;
		}
	}
}

